<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>RTTY Decoder + Histogram</title>
<style>
  body{font-family:sans-serif;padding:1rem;max-width:540px;margin:auto;}
  input,button{font-size:1rem;margin:.3rem 0;padding:.3rem;}
  #log{margin:.6rem 0;font-family:monospace;background:#f4f4f4;border:1px solid #ccc;
       height:240px;overflow-y:auto;white-space:pre-wrap;padding:.5rem;}
  #status{font-weight:bold;margin-top:.3rem;}
  canvas{border:1px solid #ccc;}
</style>
</head>
<body>
  <h2>RTTY Decoder (tab audio)</h2>

  <label>Baud <input id="baud"  type="number" value="45"  min="10" max="100"></label><br>
  <label>Shift Hz <input id="shift" type="number" value="450" min="50" max="2000"></label><br>

  <button id="btnStart">Start Decoding</button>
  <button id="btnStop"  disabled>Stop</button>
  <button id="btnReverse">Reverse Mark/Space</button>
  <div id="status">Idle</div>

  <canvas id="hist" width="520" height="120"></canvas>
  <div id="log"></div>

<script>
/* ---------- Constants & tables ------------------------------------ */
const MARK_FREQ = 1000;                       // low tone (Hz)
const SPACE_FREQ_FIXED = 1450;                // guide‑line at 1450 Hz
const HIST_LO_HZ = 800, HIST_HI_HZ = 1600;    // histogram range
const SHIFT_LTRS=0b11111, SHIFT_FIGS=0b11011;
/* Baudot tables ... (unchanged, omitted for brevity) */
const LTRS={/* … */};
const FIGS={/* … */};

/* ---------- DOM shortcuts, helpers -------------------------------- */
const logPane=document.getElementById('log');
const statusEl=document.getElementById('status');
const ctxHist=document.getElementById('hist').getContext('2d');
function log(...a){logPane.textContent+=a.join(' ')+'\n';logPane.scrollTop=1e9;}
function setStatus(t){statusEl.textContent=t;}
function majority(a){return a.reduce((s,b)=>s+b,0)>=a.length/2?1:0;}

/* ---------- Decoder state ----------------------------------------- */
const OVERSAMPLE=4;
let audioCtx, analyser, micStream, timerId, drawId;
let baud=45, shift=450, bitMs=1000/45, reverse=false;
let markBin=0, spaceBin=0;
let lastRaw=1, collecting=false, rawBuf=[], bitBuf=[], shiftState='LTRS';

/* ---------- Histogram state (set after AudioContext exists) -------- */
let histLowBin, histHighBin, histBins, histCnts, maxCnt=1;

/* ---------- Utility ----------------------------------------------- */
function hzToBin(hz){return Math.round(hz/(audioCtx.sampleRate/analyser.fftSize));}

/* ---------- FFT sampling ------------------------------------------ */
function sampleRawBit(){
  const fft=new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteFrequencyData(fft);

  /* --- histogram (only 800‑1600 Hz bins) --- */
  let peak=-1, peakVal=0;
  for(let bin=histLowBin; bin<=histHighBin; bin++){
    if(fft[bin]>peakVal){peakVal=fft[bin]; peak=bin;}
  }
  if(peak!==-1){
    const idx=peak-histLowBin;
    histCnts[idx]++; if(histCnts[idx]>maxCnt)maxCnt=histCnts[idx];
  }

  /* demod decision */
  return (fft[spaceBin] > fft[markBin]) ? 0 : 1;
}

/* ---------- Bit processing (unchanged) ---------------------------- */
function bitsToVal(a){return a.reduce((v,b,i)=>v|(b<<i),0);}
function processChar(b){/* … unchanged … */}
function processRawSample(raw){/* … unchanged … */}

/* ---------- Histogram drawing ------------------------------------ */
function drawHistogram(){
  const w=ctxHist.canvas.width, h=ctxHist.canvas.height;
  ctxHist.clearRect(0,0,w,h);

  /* bars */
  const barW=w/histBins;
  ctxHist.fillStyle='#3b82f6';
  for(let i=0;i<histBins;i++){
    const val=histCnts[i]/maxCnt;
    ctxHist.fillRect(i*barW, h-val*h, barW-1, val*h);
  }

  /* guide‑lines at 1000 & 1450 Hz */
  ctxHist.strokeStyle='green'; ctxHist.lineWidth=1;
  [MARK_FREQ, SPACE_FREQ_FIXED].forEach(freq=>{
    const x=(freq-HIST_LO_HZ)/(HIST_HI_HZ-HIST_LO_HZ)*w;
    ctxHist.beginPath(); ctxHist.moveTo(x,0); ctxHist.lineTo(x,h); ctxHist.stroke();
  });
}

/* ---------- Start / Stop ----------------------------------------- */
async function startDecoding(){
  document.getElementById('btnStart').disabled=true;
  document.getElementById('btnStop').disabled=false;

  baud=+document.getElementById('baud').value||45;
  shift=+document.getElementById('shift').value||450;
  bitMs=1000/baud; maxCnt=1;

  logPane.textContent=''; setStatus('Requesting tab audio…');

  try{
    audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    micStream=await navigator.mediaDevices.getDisplayMedia({
      video:{cursor:'never'}, audio:{echoCancellation:false}
    });
    micStream.getVideoTracks().forEach(t=>t.stop());

    /* graph: tab → BP 900‑1700 → analyser */
    const src=audioCtx.createMediaStreamSource(micStream);
    const bp =audioCtx.createBiquadFilter();
    bp.type='bandpass'; bp.frequency.value=1300; bp.Q.value=1300/800;
    analyser=audioCtx.createAnalyser(); analyser.fftSize=2048;
    src.connect(bp); bp.connect(analyser);

    /* histogram bins for 800‑1600 Hz */
    histLowBin = hzToBin(HIST_LO_HZ);
    histHighBin= hzToBin(HIST_HI_HZ);
    histBins   = histHighBin - histLowBin + 1;
    histCnts   = new Uint32Array(histBins);

    /* demod bins */
    markBin = hzToBin(reverse? MARK_FREQ+shift:MARK_FREQ);
    spaceBin= hzToBin(reverse? MARK_FREQ:MARK_FREQ+shift);
    collecting=false; lastRaw=1; shiftState='LTRS';

    timerId=setInterval(()=>processRawSample(sampleRawBit()), bitMs/OVERSAMPLE);
    drawId =setInterval(drawHistogram,100);

    setStatus('Decoding…');
  }catch(e){log('Mic error:',e); stopDecoding();}
}
function stopDecoding(){
  clearInterval(timerId); clearInterval(drawId); timerId=drawId=null;
  if(micStream)micStream.getTracks().forEach(t=>t.stop());
  if(audioCtx)audioCtx.close();
  setStatus('Idle');
  document.getElementById('btnStart').disabled=false;
  document.getElementById('btnStop').disabled=true;
}

/* ---------- UI hooks ---------------------------------------------- */
document.getElementById('btnStart').addEventListener('click',startDecoding);
document.getElementById('btnStop').addEventListener('click',stopDecoding);
document.getElementById('btnReverse').addEventListener('click',()=>{
  reverse=!reverse;
  if(analyser){
    markBin = hzToBin(reverse? MARK_FREQ+shift:MARK_FREQ);
    spaceBin= hzToBin(reverse? MARK_FREQ:MARK_FREQ+shift);
  }
  log('Reverse:',reverse?'HIGH tone = mark':'LOW tone = mark');
});
</script>
</body>
</html>
