<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>RTTY Decoder + Histogram</title>
<style>
  body{font-family:sans-serif;padding:1rem;max-width:540px;margin:auto;}
  input,button{font-size:1rem;margin:.3rem 0;padding:.3rem;}
  #log{margin:.6rem 0;font-family:monospace;background:#f4f4f4;border:1px solid #ccc;
       height:240px;overflow-y:auto;white-space:pre-wrap;padding:.5rem;}
  #status{font-weight:bold;margin-top:.3rem;}
  canvas{border:1px solid #ccc;}
</style>
</head>
<body>
  <h2>RTTY Decoder (tab audio)</h2>

  <label>Baud <input id="baud" type="number" value="45"  min="10" max="100"></label><br>
  <label>Shift Hz <input id="shift" type="number" value="450" min="50" max="2000"></label><br>

  <button id="btnStart">Start Decoding</button>
  <button id="btnStop"  disabled>Stop</button>
  <button id="btnReverse">Reverse Mark/Space</button>
  <div id="status">Idle</div>

  <canvas id="hist" width="520" height="120"></canvas>
  <div id="log"></div>

<script>
/* ---------- Constants & tables ------------------------------------ */
const MARK_FREQ = 1000;                 // low tone (Hz)
const SPACE_FREQ_FIXED = 1450;          // reference space tone
const HIST_LO_HZ = 800, HIST_HI_HZ = 1600; // histogram window
const SHIFT_LTRS = 0b11111, SHIFT_FIGS = 0b11011;

/* 5‑bit ITA‑2 tables (LSB‑first) */
const LTRS = {
  0b00011:'A',0b11001:'B',0b01110:'C',0b01001:'D',0b00001:'E',
  0b01101:'F',0b11010:'G',0b10100:'H',0b00110:'I',0b01011:'J',
  0b01111:'K',0b10010:'L',0b11100:'M',0b01100:'N',0b11000:'O',
  0b10110:'P',0b10111:'Q',0b01010:'R',0b00101:'S',0b10000:'T',
  0b00111:'U',0b11110:'V',0b10011:'W',0b11101:'X',0b10101:'Y',
  0b10001:'Z',0b00100:' '
};
const FIGS = {
  0b10110:'0',0b00011:'1',0b11001:'2',0b01110:'3',0b01001:'4',
  0b00001:'5',0b01101:'6',0b11010:'7',0b10100:'8',0b00110:'9',
  0b00100:' '
};

/* ---------- DOM helpers ------------------------------------------- */
const logPane  = document.getElementById('log');
const statusEl = document.getElementById('status');
const ctxHist  = document.getElementById('hist').getContext('2d');
function log(...a){logPane.textContent+=a.join(' ')+'\n';logPane.scrollTop=1e9;}
function setStatus(t){statusEl.textContent=t;}
function majority(a){return a.reduce((s,b)=>s+b,0)>=a.length/2?1:0;}

/* ---------- Decoder state ----------------------------------------- */
const OVERSAMPLE = 4;
let audioCtx, analyser, micStream, timerId, drawId;
let baud=45, shift=450, bitMs=1000/45, reverse=false;
let markBin=0, spaceBin=0;
let lastRaw=1, collecting=false, rawBuf=[], bitBuf=[], shiftState='LTRS';

/* ---------- Histogram state --------------------------------------- */
let histLowBin, histHighBin, histBins, histCnts, maxCnt=1;

/* ---------- Math helpers ------------------------------------------ */
function hzToBin(hz){return Math.round(hz/(audioCtx.sampleRate/analyser.fftSize));}

/* ---------- FFT sampling ------------------------------------------ */
function sampleRawBit(){
  const fft = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteFrequencyData(fft);

  /* Histogram update (only 800‑1600 Hz) */
  let peak=-1, peakVal=0;
  for(let bin=histLowBin; bin<=histHighBin; bin++){
    if(fft[bin] > peakVal){peakVal = fft[bin]; peak = bin;}
  }
  if(peak !== -1){
    const idx = peak - histLowBin;
    histCnts[idx]++; if(histCnts[idx] > maxCnt) maxCnt = histCnts[idx];
  }

  /* DEBUG print mark / space amplitudes */
  //log('space:', fft[spaceBin], 'mark:', fft[markBin]);

  /* Bit decision */
  return (fft[spaceBin] > fft[markBin]) ? 0 : 1;
}

/* ---------- Bit & character processing ---------------------------- */
function bitsToVal(a){return a.reduce((v,b,i)=>v|(b<<i),0);}
function processChar(bits){
  const v = bitsToVal(bits);
  if(v === SHIFT_LTRS){ shiftState='LTRS'; return; }
  if(v === SHIFT_FIGS){ shiftState='FIGS'; return; }
  const ch = (shiftState === 'LTRS' ? LTRS : FIGS)[v] || '?';
  log(ch);                                   // print decoded character
}
function processRawSample(raw){
  if(!collecting){
    if(lastRaw===1 && raw===0){collecting=true; rawBuf=[]; bitBuf=[];}
  }
  if(collecting){
    rawBuf.push(raw);
    if(rawBuf.length === OVERSAMPLE){
      const bit = majority(rawBuf);
      bitBuf.push(bit);
      rawBuf=[];
      if(bitBuf.length === 8){                // start + 5 + 2 stop
        processChar(bitBuf.slice(1,6));
        collecting=false;
      }
    }
  }
  lastRaw = raw;
}

/* ---------- Histogram drawing ------------------------------------- */
function drawHistogram(){
  const w = ctxHist.canvas.width, h = ctxHist.canvas.height;
  ctxHist.clearRect(0,0,w,h);

  /* bars */
  const barW = w / histBins;
  ctxHist.fillStyle = '#3b82f6';
  for(let i=0;i<histBins;i++){
    const barH = (histCnts[i] / maxCnt) * h;
    ctxHist.fillRect(i*barW, h-barH, barW-1, barH);
  }

  /* guide‑lines at 1000 & 1450 Hz */
  ctxHist.strokeStyle='green'; ctxHist.lineWidth=1;
  [MARK_FREQ, SPACE_FREQ_FIXED].forEach(freq=>{
    const x = (freq - HIST_LO_HZ) / (HIST_HI_HZ - HIST_LO_HZ) * w;
    ctxHist.beginPath(); ctxHist.moveTo(x,0); ctxHist.lineTo(x,h); ctxHist.stroke();
  });
}

/* ---------- Start / Stop ------------------------------------------ */
async function startDecoding(){
  document.getElementById('btnStart').disabled=true;
  document.getElementById('btnStop').disabled=false;

  baud  = +document.getElementById('baud').value  || 45;
  shift = +document.getElementById('shift').value || 450;
  bitMs = 1000 / baud; maxCnt = 1;

  logPane.textContent=''; setStatus('Requesting tab audio…');

  try{
    /* capture current‑tab audio */
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    micStream = await navigator.mediaDevices.getDisplayMedia({
      video:{cursor:'never'}, audio:{echoCancellation:false}
    });
    micStream.getVideoTracks().forEach(t=>t.stop());

    /* graph: tab → BP 900‑1700 → analyser */
    const src = audioCtx.createMediaStreamSource(micStream);
/* 1.  2‑pole high‑pass at 900 Hz */
const hp = audioCtx.createBiquadFilter();
hp.type = 'highpass';
hp.frequency.value = 900;      // –3 dB corner
hp.Q.value = 0.707;            // Butterworth (maximally flat)

/* 2.  2‑pole low‑pass at 1700 Hz */
const lp = audioCtx.createBiquadFilter();
lp.type = 'lowpass';
lp.frequency.value = 1700;     // –3 dB corner
lp.Q.value = 0.707;

/* 3.  analyser */
analyser = audioCtx.createAnalyser();
analyser.fftSize = 2048;

/* connect the chain */
src.connect(hp);
hp.connect(lp);
lp.connect(analyser);

    /* histogram bins for 800‑1600 Hz */
    histLowBin  = hzToBin(HIST_LO_HZ);
    histHighBin = hzToBin(HIST_HI_HZ);
    histBins    = histHighBin - histLowBin + 1;
    histCnts    = new Uint32Array(histBins);

    /* demod bins */
    markBin  = hzToBin(reverse? MARK_FREQ+shift : MARK_FREQ);
    spaceBin = hzToBin(reverse? MARK_FREQ        : MARK_FREQ+shift);
    collecting=false; lastRaw=1; shiftState='LTRS';

    timerId = setInterval(()=>processRawSample(sampleRawBit()), bitMs/OVERSAMPLE);
    drawId  = setInterval(drawHistogram,100);

    setStatus('Decoding…');
  }catch(e){log('Mic error:',e); stopDecoding();}
}
function stopDecoding(){
  clearInterval(timerId); clearInterval(drawId); timerId=drawId=null;
  if(micStream) micStream.getTracks().forEach(t=>t.stop());
  if(audioCtx)  audioCtx.close();
  setStatus('Idle');
  document.getElementById('btnStart').disabled=false;
  document.getElementById('btnStop').disabled=true;
}

/* ---------- UI hooks ---------------------------------------------- */
document.getElementById('btnStart').addEventListener('click',startDecoding);
document.getElementById('btnStop' ).addEventListener('click',stopDecoding);
document.getElementById('btnReverse').addEventListener('click',()=>{
  reverse=!reverse;
  if(analyser){
    markBin  = hzToBin(reverse? MARK_FREQ+shift : MARK_FREQ);
    spaceBin = hzToBin(reverse? MARK_FREQ        : MARK_FREQ+shift);
  }
  log('Reverse:', reverse? 'HIGH tone = mark' : 'LOW tone = mark');
});
</script>
</body>
</html>
